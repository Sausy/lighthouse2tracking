module DataBuffer_sync (
      input io_dataIn_valid,
      output io_dataIn_ready,
      input [5:0] ioINPUT_npoly,
      input [15:0] ioINPUT_pulse_width,
      input [23:0] ioINPUT_pulse_timestamp,
      input [16:0] ioINPUT_beamWord,
      input [4:0] ioINPUT_id,
      //Second Input
      input [15:0] ioINPUT2_pulse_width,
      input [23:0] ioINPUT2_pulse_timestamp,
      input [16:0] ioINPUT2_beamWord,
      input [4:0] ioINPUT2_id,
      //outData
      output io_dataOut_valid,
      input   io_dataOut_ready,
      output [5:0] io_npoly,
      output [15:0] io_pulse_width,
      output [23:0] io_pulse_timestamp,
      output [16:0] io_beamWord,
      output [4:0] io_id,


      input   Slow_clk);

      //=================================
      //====Pre dev's ====
      reg [5:0] outBuffer_npoly;
      reg [15:0] outBuffer_pulse_width;
      reg [23:0] outBuffer_pulse_timestamp;
      reg [16:0] outBuffer_beamWord;
      reg [4:0] outBuffer_id;
      assign io_npoly = outBuffer_npoly;
      assign io_pulse_width = outBuffer_pulse_width;
      assign io_pulse_timestamp = outBuffer_pulse_timestamp;
      assign io_beamWord = outBuffer_beamWord;
      assign io_id = outBuffer_id;

      /*reg [2:0] dataSelect = 3'd0;

      reg dataPushed;
      reg dataPull;
      reg dataRdy;
      reg lock;
      reg started;*/

      reg [2:0] fsm_stateNext = 3'd0;
      reg [2:0] fsm_stateReg = 3'd0;

      //wire DoneProc;
      //assign dataPull = (dataSelect == 3'd1);
      //=================================
      //----Combinatorical logic block
      wire SyncInputEvent;
      wire SyncOutputEvent;
      assign SyncInputEvent = (io_dataIn_valid && io_dataIn_ready);
      assign SyncOutputEvent = (io_dataOut_valid && io_dataOut_ready);

      reg reg_dataIn_ready;
      reg reg_dataOut_valid;
      assign io_dataIn_ready = reg_dataIn_ready;
      assign io_dataOut_valid = reg_dataOut_valid;

      wire flagEqualData;
      assign flagEqualData = (ioINPUT2_pulse_timestamp == ioINPUT_pulse_timestamp);

      always @ (*) begin
        reg_dataOut_valid = 1'b0;
        case(fsm_stateReg)
          3'd0: begin
          end
          3'd1: begin
          end
          3'd2: begin
            reg_dataOut_valid = 1'b1;
          end
          default: begin
          end
        endcase
      end

      always @ (*) begin
        reg_dataIn_ready = 1'b0;
        case(fsm_stateReg)
          3'd0: begin
          end
          3'd1: begin
          end
          3'd2: begin
            if(SyncOutputEvent)begin
              reg_dataIn_ready = 1'b1;
            end
          end
          default: begin
          end
        endcase
      end


      /*
      always @ (*) begin
        fsm_stateNext = fsm_stateReg;
        case(fsm_stateReg)
          3'd0: begin
            if(io_pulseIn_valid)begin
              fsm_stateNext = 3'd1;
            end
          end
          3'd1: begin
            fsm_stateNext = 3'd2;
          end
          3'd2: begin
            if(SyncOutputEvent)begin
              fsm_stateNext = 3'd0;
            end
          end
          default : begin
          end
        endcase
      end

      always @ (posedge Slow_clk) begin
        fsm_stateReg <= fsm_stateNext;
      end
      */

      always @ (posedge Slow_clk ) begin
        //fsm_stateNext = fsm_stateReg;
        case(fsm_stateReg)
          3'd0: begin
            if(io_pulseIn_valid)begin
              fsm_stateReg <= 3'd1;
            end
          end
          3'd1: begin
            fsm_stateReg <= 3'd2;
          end
          3'd2: begin
            if(SyncOutputEvent)begin
              fsm_stateReg <= 3'd0;
            end
          end
          default : begin
          end
        endcase
      end

      always @ ( posedge Slow_clk ) begin
        /*
        outBuffer_npoly = ioINPUT_npoly;
        outBuffer_pulse_width = ioINPUT_pulse_width;
        outBuffer_pulse_timestamp = ioINPUT_pulse_timestamp;
        outBuffer_beamWord = ioINPUT_beamWord;
        outBuffer_id = ioINPUT_id;
        */

        case(fsm_stateReg)
          3'd0: begin
          end
          3'd1: begin
            outBuffer_npoly <= ioINPUT_npoly;
            outBuffer_pulse_width <= ioINPUT_pulse_width;
            outBuffer_pulse_timestamp <= ioINPUT_pulse_timestamp;
            outBuffer_beamWord <= ioINPUT_beamWord;
            outBuffer_id <= ioINPUT_id;
          end
          3'd2: begin
          end
          default: begin
          end
        endcase
      end
      //=================================
      //----Sequential Logic blocks
