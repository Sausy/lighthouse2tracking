/*

always @ ( * ) begin
  io_dataIn_ready <= 1'b1;
  if(SyncInputEvent)begin

  end
end

/*
assign io_npoly = ioINPUT_npoly;
assign io_pulse_width = ioINPUT_pulse_width;
assign io_pulse_timestamp = ioINPUT_pulse_timestamp;
assign io_beamWord = ioINPUT_beamWord;
assign io_id = ioINPUT_id;
assign io_dataOut_valid = io_dataIn_valid;
assign io_dataIn_ready = io_dataOut_ready;
*/

/*reg reg_dataIn_ready = 1'b0;
assign io_dataIn_ready = reg_dataIn_ready;
reg reg_dataOut_valid = 1'b0;
assign io_dataOut_valid = reg_dataOut_valid;
*/


/*


reg lock;
reg processingDone;

always @ ( * ) begin
  io_dataIn_ready = 1'b0;
  case (fsm_state)
    8'd0: begin
    end
    8'd1: begin
    end
    8'd2: begin
    end
    8'd3: begin
      if (SyncOutputEvent) begin
        io_dataIn_ready = 1'b1;
      end
    end
    default: begin
    end
  endcase
end

always @ ( * ) begin
  io_dataOut_valid = 1'b0;
  case (fsm_state)
    8'd0: begin
    end
    8'd1: begin
    end
    8'd2: begin
    end
    8'd3: begin
      io_dataOut_valid = 1'b1;
    end
    default: begin
    end
  endcase
end

always @ (posedge Slow_clk) begin
  fsm_state <= fsm_stateNext;
end

always @ (*) begin
  fsm_stateNext = fsm_state;
  case (fsm_state)
    8'd0: begin
      if(io_pulseIn_valid)begin
        fsm_stateNext = 8'd1;
      end
    end
    8'd1: begin
      fsm_stateNext = 8'd2;
    end
    8'd2: begin
      if(flagDone)begin
        fsm_stateNext = 8'd3;
      end
    end
    8'd3: begin
      if(SyncOutputEvent)begin
        fsm_stateNext = 8'd0;
      end
    end
    default: begin
      fsm_stateNext = 8'd0;
    end
  endcase
end

reg start_flag;
always @ (*) begin
  start_flag = 1'b0;
  case (fsm_state)
    8'd0: begin
    end
    8'd1: begin
      start_flag = 1'b1;
    end
    8'd2: begin
    end
    8'd3: begin
    end
    default: begin
    end
  endcase
end

reg keepRunning;
reg flagDone;
always @ ( posedge Slow_clk ) begin
  if(keepRunning)begin
    outBuffer_npoly <= ioINPUT_npoly;
    outBuffer_pulse_width <= ioINPUT_pulse_width;
    outBuffer_pulse_timestamp <= ioINPUT_pulse_timestamp;
    outBuffer_beamWord <= ioINPUT_beamWord;
    outBuffer_id <= ioINPUT_id;
    keepRunning <= 1'b0;
    flagDone <= 1'b1;
  end else begin
    if(start_flag)begin
      keepRunning <= 1'b1;
    end
  end

end


always @ ( posedge Slow_clk ) begin
  case (fsm_state)
    8'd0: begin
      //if(io_dataIn_valid)begin
      //  fsm_state <= 8'd1;
      //end
    end
    8'd1: begin //Get new Data --- Select Input Data
        //reg_dataIn_ready <= 1'b0;
        //if(SyncInputEvent)begin

          //outBuffer_npoly <= ioINPUT_npoly;
          //outBuffer_pulse_width <= ioINPUT_pulse_width;
          //outBuffer_pulse_timestamp <= ioINPUT_pulse_timestamp;
          //outBuffer_beamWord <= ioINPUT_beamWord;
          //outBuffer_id <= ioINPUT_id;


          //fsm_state <= 8'd2;
        //end
        //lock <= 1'b0;
    end
    8'd2: begin
        //fsm_state <= 8'd3;
        //Acually the ad

        //if(processingDone)begin
        //  fsm_state <= 8'd3;
      //    lock <= 1'b1;
      //  end

        //reg_dataOut_valid <= 1'b1;
        if(flagDone)begin
          io_npoly <= outBuffer_npoly;
          io_pulse_width <= outBuffer_pulse_width;
          io_pulse_timestamp <= outBuffer_pulse_timestamp;
          io_beamWord <= outBuffer_beamWord;
          io_id <= outBuffer_id;
        end
    end
    8'd3: begin //Transmit Data
      //if(SyncOutputEvent)begin
        //io_npoly <= outBuffer_npoly;
        //io_pulse_width <= outBuffer_pulse_width;
        //io_pulse_timestamp <= outBuffer_pulse_timestamp;
        //io_beamWord <= outBuffer_beamWord;
        //io_id <= outBuffer_id;

        //if(reg_dataOut_valid)begin
        //reg_dataOut_valid <= 1'b1;
        //reg_dataIn_ready <= 1'b1;
        //fsm_state <= 8'd0;
        //end
      //end

    end
    default: begin
      //fsm_state <= 8'd0;
    end
  endcase
end
*/

//===================================================
//==== write processing here
/*
always @ ( posedge Slow_clk ) begin
  if(lock)begin
    processingDone <= 1'b0;
  end else begin
    if(processingDone)begin
      processingDone <= 1'b0;
    end else begin
      //============ YOUR Processing ===== ///

      //============ if done >>> processingDone <= 1'b1;
      processingDone <= 1'b1;
    end
  end
end
*/

//==================================================



/*
reg reg_dataIn_ready = 1'b0;
assign io_dataIn_ready = reg_dataIn_ready;
reg reg_dataOut_valid = 1'b0;
assign io_dataOut_valid = reg_dataOut_valid;


wire SyncInputEvent;
wire SyncOutputEvent;
assign SyncInputEvent = (io_dataIn_valid && reg_dataIn_ready);
assign SyncOutputEvent = (reg_dataOut_valid && io_dataOut_ready);

reg [5:0] outBuffer_npoly;
reg [15:0] outBuffer_pulse_width;
reg [23:0] outBuffer_pulse_timestamp;
reg [16:0] outBuffer_beamWord;
reg [4:0] outBuffer_id;

reg inputSyncFlag = 1'b0;
reg rdyForNewInputData = 1'b0;
reg outputSyncFlag = 1'b0;
reg OputDataRdy = 1'b0;
always @ ( posedge Slow_clk ) begin
  //SyncLine INPUT
  if (inputSyncFlag)begin
    reg_dataIn_ready <= 1'b0;
    inputSyncFlag <= 1'b0;
  end else begin
    inputSyncFlag <= 1'b1;
    if(rdyForNewInputData)begin
      reg_dataIn_ready <= 1'b1;
    end
  end

  //SyncLine Output
  if (outputSyncFlag)begin
    reg_dataOut_valid <= 1'b0;
    outputSyncFlag <= 1'b0;
  end else begin
    outputSyncFlag <= 1'b1;
    if(OputDataRdy)begin
      reg_dataOut_valid <= 1'b1;
    end
  end


  //push new data from INPUT
  if(SyncInputEvent)begin
    outBuffer_npoly <= ioINPUT_npoly;
    outBuffer_pulse_width <= ioINPUT_pulse_width;
    outBuffer_pulse_timestamp <= ioINPUT_pulse_timestamp;
    outBuffer_beamWord <= ioINPUT_beamWord;
    outBuffer_id <= ioINPUT_id;
    rdyForNewInputData <= 1'b0;
    OputDataRdy <= 1'b1;
  end

  //push new data to OUTPUT
  if(SyncOutputEvent)begin
    io_npoly <= outBuffer_npoly;
    io_pulse_width <= outBuffer_pulse_width;
    io_pulse_timestamp <= outBuffer_pulse_timestamp;
    io_beamWord <= outBuffer_beamWord;
    io_id <= outBuffer_id;
    OputDataRdy <= 1'b0;
    rdyForNewInputData <= 1'b1;
  end
end

*/





/*

reg [7:0] fsm_state = 8'd0;
reg [7:0] fsm_next = 8'd1;
reg inputWasValid = 1'b0;

//wire pullInput;
//assign pullInput = (io_dataOut_valid && io_dataOut_ready);

reg processingDone = 1'b1;
reg OutputBufferEmpty = 1'b0;
reg pushOutputDone = 1'b0;

always @ ( posedge Slow_clk ) begin
  if(processingDone)begin
    if(io_dataIn_ready && io_dataIn_valid)begin
      processingDone <= 1'b0;
    end
  end else begin
    if(OutputBufferEmpty)begin
      processingDone <= 1'b1;
    end
  end
end

always @ ( posedge Slow_clk ) begin
  if(processingDone)begin
    OutputBufferEmpty <= 1'b0;
  end else begin
    if(pushOutputDone)begin
      if(io_dataOut_ready && io_dataOut_valid)begin
        pushOutputDone <= 1'b0;
      end
    end else begin
      //OutputBufferEmpty <= 1'b0;
      case(fsm_state)
        8'd0 : begin
          io_npoly <= ioINPUT_npoly;
          io_pulse_width <= ioINPUT_pulse_width;
          io_pulse_timestamp <= ioINPUT_pulse_timestamp;
          io_beamWord <= ioINPUT_beamWord;
          io_id <= ioINPUT_id;

          fsm_state <= 8'd1;
          //pushOutputDone <= 1'b1;
        end
        default : begin
          fsm_state <= 8'd0;
          //fsm_next <= 8'd1;
          //processingDone <= 1'b1;
          OutputBufferEmpty <= 1'b1;
          //pushOutputDone <= 1'b0;
        end
      endcase
      pushOutputDone <= 1'b1;
    end
  end
end



always @ ( * ) begin
  io_dataIn_ready = 1'b0;
  if(processingDone)begin
    io_dataIn_ready = 1'b1;
  end
end
always @ ( * ) begin
  io_dataOut_valid = 1'b0;
  if(pushOutputDone)begin
    io_dataOut_valid = 1'b1;
  end
end

*/
/*

always @ ( * ) begin
  io_dataOut_valid = 1'b0;
  if(unlocked)begin
    io_dataOut_valid = 1'b1;
  end
end
*/





      always @ ( posedge Slow_clk ) begin
        //reg_dataIn_ready <= io_dataOut_ready;
        //reg_dataOut_valid <= io_dataIn_valid;


        reg_dataIn_ready <= 1'b0;
        if(io_dataOut_ready)begin
          reg_dataIn_ready <= 1'b1;
        end
        if(SyncInputEvent)begin
          reg_dataIn_ready <= 1'b0;
        end



        reg_dataOut_valid <= 1'b0;
        if(io_dataIn_valid)begin
          reg_dataOut_valid <= 1'b1;
        end
        if(SyncOutputEvent)begin
          reg_dataOut_valid <= 1'b0;
        end
      end
